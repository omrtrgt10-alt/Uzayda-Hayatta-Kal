<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Space Clash</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

    *{margin:0;padding:0;box-sizing:border-box}
    html,body{height:100%}
    body{
      background:#000;
      display:flex;justify-content:center;align-items:center;
      min-height:100vh;font-family:'Orbitron',monospace;
      overflow:hidden;cursor:none;color:#fff;
    }
    #gameContainer{
      position:relative;width:100vw;max-width:1280px;aspect-ratio:16/9;
      background:linear-gradient(135deg,#000014 0%,#000030 100%);
      box-shadow:0 0 100px rgba(42,102,255,.18);
      border:1px solid rgba(255,255,255,.06);
    }
    canvas{display:block;width:100%;height:100%;image-rendering:crisp-edges}

    #ui{position:absolute;inset:0;pointer-events:none}
    #score{
      position:absolute;top:16px;left:50%;transform:translateX(-50%);
      font-size:20px;font-weight:700;letter-spacing:1.6px;text-shadow:0 0 20px rgba(255,255,255,.4);
      mix-blend-mode:screen;user-select:none
    }
    #combo{
      position:absolute;top:46px;left:50%;transform:translateX(-50%);
      color:#ffd700;font-size:14px;font-weight:400;opacity:0;transition:opacity .25s, transform .25s;
      user-select:none
    }
    #combo.active{opacity:1;transform:translateX(-50%) scale(1.05)}

    #menu,#gameOver{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;pointer-events:auto}
    .btn{
      background:linear-gradient(135deg,#2a66ff,#ff2a6d);
      border:none;padding:14px 36px;margin:8px;color:#fff;font-size:16px;font-weight:800;
      letter-spacing:1px;cursor:pointer;transition:transform .2s, box-shadow .2s;
      box-shadow:0 6px 24px rgba(42,102,255,.45);font-family:'Orbitron',monospace;border-radius:12px
    }
    .btn:hover{transform:translateY(-1px) scale(1.03);box-shadow:0 10px 40px rgba(42,102,255,.65)}
    #instructions{margin-top:18px;color:rgba(255,255,255,.72);font-size:12px;line-height:1.7}
    #gameOver{display:none}
    #gameOver h2{color:#ff2a6d;font-size:40px;font-weight:900;text-shadow:0 0 30px rgba(255,42,109,.8);margin-bottom:10px}
    #finalScore{font-size:18px;margin-bottom:18px}

    #muteBtn,#pauseBtn{
      position:absolute;top:14px;width:40px;height:40px;display:grid;place-items:center;
      background:rgba(255,255,255,.1);border:2px solid rgba(255,255,255,.28);color:#fff;
      font-size:18px;cursor:pointer;transition:background .2s, transform .2s;pointer-events:auto;
      border-radius:10px;font-family:'Orbitron',monospace
    }
    #muteBtn{right:14px}
    #pauseBtn{right:62px}
    #muteBtn:hover,#pauseBtn:hover{background:rgba(255,255,255,.2);transform:translateY(-1px)}

    /* Toast / Achievements */
    #toast{
      position:absolute;bottom:18px;left:50%;transform:translateX(-50%) translateY(20px);
      background:rgba(10,10,20,.75);border:1px solid rgba(255,255,255,.12);backdrop-filter:blur(6px);
      padding:10px 16px;border-radius:12px;font-size:12px;opacity:0;transition:opacity .25s, transform .25s;
      pointer-events:none;white-space:nowrap;box-shadow:0 10px 30px rgba(0,0,0,.35)
    }
    #toast.show{opacity:1;transform:translateX(-50%) translateY(0)}

    /* Pause veil */
    #veil{
      position:absolute;inset:0;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);
      display:none;align-items:center;justify-content:center;pointer-events:none
    }
    #veil span{font-size:32px;font-weight:900;letter-spacing:2px;text-shadow:0 0 20px rgba(255,255,255,.4)}
    #veil.show{display:flex}
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
      <div id="score">0</div>
      <div id="combo">COMBO x1</div>
      <button id="pauseBtn">‚è∏</button>
      <button id="muteBtn">‚ô™</button>

      <div id="menu">
        <button class="btn" onclick="startGame()">START</button>
        <div id="instructions">
          <p>FOLLOW YOUR MOUSE / FINGER ‚Üï</p>
          <p>CLICK / TAP / SPACE to SWITCH COLOR</p>
          <p>MATCH YOUR COLOR WITH THE RAILS</p>
        </div>
      </div>

      <div id="gameOver">
        <h2>GAME OVER</h2>
        <div id="finalScore">SCORE: 0</div>
        <button class="btn" onclick="restartGame()">RESTART</button>
      </div>

      <div id="veil"><span>PAUSED</span></div>
      <div id="toast"></div>
    </div>
  </div>

  <script>
    // ===== Canvas & DPR =====
    const container = document.getElementById('gameContainer');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const comboEl = document.getElementById('combo');
    const toastEl = document.getElementById('toast');
    const veilEl  = document.getElementById('veil');

    function resizeCanvas(){
      const rect = container.getBoundingClientRect();
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      canvas.style.width  = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      canvas.width  = Math.round(rect.width  * dpr);
      canvas.height = Math.round(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener('resize', resizeCanvas, {passive:true});
    resizeCanvas();

    // ===== Game State =====
    let gameRunning = false;
    let paused = false;
    let score = 0;
    let combo = 1;
    let difficulty = 1;
    let baseSpeed = 4;
    let mouseY = canvas.height/2;
    let screenShake = 0;
    let muted = false;
    let lastTime = 0;
    let playTime = 0; // for achievements

    let highScore = Number(localStorage.getItem('spaceclash_hs') || 0);

    // Ship
    const ship = {
      x: 220,
      y: canvas.height/2,
      targetY: canvas.height/2,
      size: 20,
      color: '#2a66ff',
      isBlue: true,
      trail: [],
      glow: 0
    };

    // Layers
    let starsFar = [], starsMid = [], starsNear = [];
    let gates = [];
    let powerUps = [];
    let particles = [];

    // Timers / Effects
    let ghostTimer = 0;
    let slowTimer  = 0;
    let comboTimer = 0;

    // UI buttons
    const muteBtn  = document.getElementById('muteBtn');
    const pauseBtn = document.getElementById('pauseBtn');

    // ===== Audio (WebAudio minimal SFX) =====
    let audioCtx;
    function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
    function beep(freq=440, dur=0.08, type='sine', vol=0.03){
      if (muted) return;
      try{
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type; o.frequency.value = freq;
        o.connect(g); g.connect(audioCtx.destination);
        g.gain.value = vol;
        o.start(); o.stop(audioCtx.currentTime + dur);
      }catch(e){}
    }
    function vibrate(ms=20){ if (navigator.vibrate) navigator.vibrate(ms); }
    const sfxGood  = ()=>{ beep(880,.06,'square'); vibrate(10); };
    const sfxOkay  = ()=>{ beep(660,.05,'triangle'); };
    const sfxPower = ()=>{ beep(1200,.08,'sawtooth'); vibrate(15); };
    const sfxFail  = ()=>{ beep(180,.25,'sine',.05); };

    // ===== Helpers =====
    function showToast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      setTimeout(()=>toastEl.classList.remove('show'), 1400);
    }

    // ===== Stars (Parallax) =====
    function seedStars() {
      starsFar = []; starsMid=[]; starsNear=[];
      const W = container.clientWidth, H = container.clientHeight;
      for (let i=0;i<80;i++) starsFar.push({x:Math.random()*W,y:Math.random()*H,s:1, sp:0.15 + Math.random()*0.15, b:0.3+Math.random()*0.3});
      for (let i=0;i<60;i++) starsMid.push({x:Math.random()*W,y:Math.random()*H,s:1.5,sp:0.35 + Math.random()*0.25, b:0.5+Math.random()*0.4});
      for (let i=0;i<40;i++) starsNear.push({x:Math.random()*W,y:Math.random()*H,s:2, sp:0.6 + Math.random()*0.4, b:0.7+Math.random()*0.3});
    }
    seedStars();
    window.addEventListener('resize', seedStars);

    // ===== Input (mouse/touch/pointer) =====
    function setMouseYFromClient(clientY){
      const rect = canvas.getBoundingClientRect();
      mouseY = (clientY - rect.top) * (canvas.height / rect.height);
    }
    canvas.addEventListener('pointermove', e => setMouseYFromClient(e.clientY), {passive:true});
    canvas.addEventListener('mousemove',   e => setMouseYFromClient(e.clientY), {passive:true});
    canvas.addEventListener('touchstart',  e => { if(e.touches[0]) setMouseYFromClient(e.touches[0].clientY); }, {passive:true});
    canvas.addEventListener('touchmove',   e => { if(e.touches[0]) setMouseYFromClient(e.touches[0].clientY); }, {passive:true});
    canvas.addEventListener('click', switchColor);
    canvas.addEventListener('touchend', ()=>switchColor(), {passive:true});

    document.addEventListener('keydown', (e)=>{
      if (e.code === 'Space'){ e.preventDefault(); switchColor(); }
      if (e.code === 'KeyP' || e.code === 'Escape'){ togglePause(); }
    });

    // ===== Color switch =====
    function switchColor(){
      if (!gameRunning || paused) return;
      ship.isBlue = !ship.isBlue;
      ship.color = ship.isBlue ? '#2a66ff' : '#ff2a6d';
      screenShake = Math.max(screenShake, 5);
      ship.glow = 1;

      // flip particles
      for (let i=0;i<12;i++){
        particles.push({
          x: ship.x, y: ship.y,
          vx: (Math.random()*6 - 3), vy: (Math.random()*6 - 3),
          life: 1, color: ship.color
        });
      }
      beep(ship.isBlue ? 520 : 640, .05, 'square', .03);
    }

    // ===== UI buttons =====
    muteBtn.addEventListener('click', ()=>{
      muted = !muted;
      muteBtn.textContent = muted ? 'üîá' : '‚ô™';
      if (!muted) ensureAudio();
    });
    pauseBtn.addEventListener('click', togglePause);

    function togglePause(){
      if (!gameRunning) return;
      paused = !paused;
      veilEl.classList.toggle('show', paused);
      if (!paused){ lastTime = performance.now(); requestAnimationFrame(gameLoop); }
    }

    // ===== Spawning =====
    let lastGapY = container.clientHeight/2;
    function spawnGate(){
      const H = container.clientHeight;
      const baseGap = Math.max(150 - difficulty*5, 80);
      const maxStep = 80;
      const target = lastGapY + (Math.random()*2-1)*maxStep;
      const gapY = Math.max(60, Math.min(H - baseGap - 60, target));
      gates.push({ x: container.clientWidth + 50, gapY, gapSize: baseGap, width: 40, passed:false });
      lastGapY = gapY;
    }
    function spawnPowerUp(){
      // biraz seyrek; zorluk arttƒ±k√ßa olasƒ±lƒ±k artar
      const p = 0.008 + Math.min(0.01, difficulty*0.0006);
      if (Math.random() < p){
        const types = ['ghost','slow','points'];
        const type = types[Math.floor(Math.random()*types.length)];
        const H = container.clientHeight;
        powerUps.push({
          x: container.clientWidth + 50,
          y: Math.random()*(H-120)+60,
          type, size: 22, collected:false, rot: Math.random()*Math.PI*2
        });
      }
    }

    // ===== Start / End =====
    function startGame(){
      ensureAudio();
      gameRunning = true; paused = false;
      score = 0; combo = 1; difficulty = 1; baseSpeed = 4;
      gates.length = 0; powerUps.length = 0; particles.length = 0;
      ghostTimer = 0; slowTimer = 0; comboTimer = 0; playTime = 0;
      ship.isBlue = true; ship.color='#2a66ff'; ship.y = container.clientHeight/2; ship.targetY = ship.y; ship.trail.length=0;
      screenShake = 0;

      document.getElementById('menu').style.display = 'none';
      document.getElementById('gameOver').style.display = 'none';
      veilEl.classList.remove('show');

      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
      showToast('Good luck, Pilot!');
    }
    function restartGame(){ startGame(); }

    function endGame(){
      gameRunning = false;
      if (score > highScore){
        highScore = score;
        localStorage.setItem('spaceclash_hs', String(highScore));
        showToast('New High Score!');
      }
      document.getElementById('finalScore').textContent = `SCORE: ${score} (BEST ${highScore})`;
      document.getElementById('gameOver').style.display = 'block';
      // Optional: auto show menu after a delay? keep minimal.
    }

    // ===== Update (delta-time) =====
    function update(dt){
      if (!gameRunning || paused) return;

      playTime += dt;

      // target follow (smooth)
      ship.targetY = mouseY;
      ship.y += (ship.targetY - ship.y) * Math.min(1, 10*dt);
      // clamp
      const H = container.clientHeight;
      ship.y = Math.max(ship.size, Math.min(H-ship.size, ship.y));

      // trail
      ship.trail.unshift({x: ship.x, y: ship.y});
      if (ship.trail.length > 10) ship.trail.pop();
      ship.glow *= Math.pow(0.95, (dt*60));
      screenShake *= Math.pow(0.9, (dt*60));

      // effective speed (slow power-up)
      const effSpeed = baseSpeed * (slowTimer>0 ? 0.7 : 1);
      const step = effSpeed * 60 * dt;

      // stars
      const W = container.clientWidth;
      const starBands = [
        {arr:starsFar, m:0.7},
        {arr:starsMid, m:1.0},
        {arr:starsNear,m:1.3}
      ];
      starBands.forEach(b=>{
        b.arr.forEach(s=>{
          s.x -= s.sp * step * b.m;
          if (s.x < 0){ s.x = W; s.y = Math.random()*H; }
        });
      });

      // gates
      gates = gates.filter(gate=>{
        gate.x -= step;

        // collision window when overlapping x
        const halfW = gate.width/2;
        const shipHalf = ship.size;
        const xOverlap = ship.x + shipHalf > gate.x - halfW && ship.x - shipHalf < gate.x + halfW;

        if (xOverlap && !gate.passed){
          const blueY = gate.gapY;
          const redY  = gate.gapY + gate.gapSize;
          const onBlueRail = Math.abs(ship.y - blueY) < 15;
          const onRedRail  = Math.abs(ship.y - redY ) < 15;
          const inGap = ship.y > gate.gapY && ship.y < gate.gapY + gate.gapSize;

          if (ghostTimer <= 0){
            if (onBlueRail || onRedRail){
              const correct = (onBlueRail && ship.isBlue) || (onRedRail && !ship.isBlue);
              if (!correct){ sfxFail(); endGame(); return false; }
              // correct rail
              score += Math.floor(10 * combo);
              combo++; comboTimer = 2.5;
              gate.passed = true;
              comboEl.classList.add('active');
              screenShake = Math.max(screenShake, 4);
              sfxGood();
              if (combo === 5) showToast('Combo x5!');
              if (combo === 10) showToast('Combo x10!!');
            }else if (inGap){
              score += 5; gate.passed = true; sfxOkay();
            }else{
              sfxFail(); endGame(); return false;
            }
          }else{
            // Ghost: free pass
            if (!gate.passed){ score += 5; gate.passed = true; }
          }
        }

        return gate.x > -60;
      });

      // spawn gates with spacing
      if (gates.length === 0 || gates[gates.length-1].x < W - 320){
        spawnGate();
      }

      // powerups
      powerUps = powerUps.filter(p=>{
        p.x -= step; p.rot += dt;
        const dx = p.x - ship.x, dy = p.y - ship.y;
        const dist = Math.hypot(dx,dy);
        if (dist < 30 && !p.collected){
          p.collected = true;
          switch(p.type){
            case 'points':
              score += 60; sfxPower(); showToast('+60 Points');
              break;
            case 'slow':
              slowTimer = 3.2; sfxPower(); showToast('Time Slow');
              break;
            case 'ghost':
              ghostTimer = 3; sfxPower(); showToast('Ghost Shield');
              break;
          }
          return false;
        }
        return p.x > -60;
      });

      spawnPowerUp();

      // particles
      particles = particles.filter(p=>{
        p.x += p.vx*dt*60; p.y += p.vy*dt*60; p.life -= 0.02*60*dt;
        return p.life > 0;
      });

      // difficulty curve
      if (score > difficulty*100){
        difficulty++;
        baseSpeed += 0.55;
        showToast('Speed Up');
      }

      // timers
      if (ghostTimer>0) ghostTimer -= dt;
      if (slowTimer>0)  slowTimer  -= dt;
      if (combo>1){
        comboTimer -= dt;
        if (comboTimer <= 0){ combo = 1; comboEl.classList.remove('active'); }
      }

      // achievements (lightweight)
      if (playTime>30 && Math.abs(playTime-30)<dt) showToast('30s Survivor');
      if (score>=500 && score-500 < 10) showToast('500 Points!');
      if (score>=1000 && score-1000 < 10) showToast('1K Club!');

      // UI
      scoreEl.textContent = `${score} ‚Äî BEST ${highScore}`;
      comboEl.textContent = `COMBO x${combo}`;
    }

    // ===== Draw =====
    function draw(){
      const W = container.clientWidth, H = container.clientHeight;

      // clear bg gradient
      const gradient = ctx.createLinearGradient(0,0,W,H);
      gradient.addColorStop(0,'#000014'); gradient.addColorStop(1,'#000030');
      ctx.fillStyle = gradient; ctx.fillRect(0,0,W,H);

      // screen shake
      if (screenShake>0.1){ ctx.save(); ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake); }

      // stars
      function drawStars(arr){
        arr.forEach(s=>{
          ctx.fillStyle = `rgba(255,255,255,${s.b*0.9})`;
          ctx.fillRect(s.x, s.y, s.s, s.s);
        });
      }
      drawStars(starsFar); drawStars(starsMid); drawStars(starsNear);

      // gates
      gates.forEach(gate=>{
        // walls
        ctx.fillStyle = 'rgba(255,255,255,0.09)';
        ctx.fillRect(gate.x - gate.width/2, 0, gate.width, gate.gapY);
        ctx.fillRect(gate.x - gate.width/2, gate.gapY + gate.gapSize, gate.width, H);

        // rails with glow + small icons for accessibility
        ctx.lineWidth = 3; ctx.shadowBlur = 16;

        // Blue (top)
        ctx.strokeStyle = '#2a66ff'; ctx.shadowColor = '#2a66ff';
        ctx.beginPath(); ctx.moveTo(gate.x - gate.width/2, gate.gapY); ctx.lineTo(gate.x + gate.width/2, gate.gapY); ctx.stroke();
        // triangle icon
        ctx.beginPath(); ctx.moveTo(gate.x, gate.gapY-8); ctx.lineTo(gate.x-6, gate.gapY+4); ctx.lineTo(gate.x+6, gate.gapY+4); ctx.closePath(); ctx.stroke();

        // Red (bottom)
        ctx.strokeStyle = '#ff2a6d'; ctx.shadowColor = '#ff2a6d';
        ctx.beginPath(); ctx.moveTo(gate.x - gate.width/2, gate.gapY + gate.gapSize); ctx.lineTo(gate.x + gate.width/2, gate.gapY + gate.gapSize); ctx.stroke();
        // circle icon
        ctx.beginPath(); ctx.arc(gate.x, gate.gapY + gate.gapSize, 6, 0, Math.PI*2); ctx.stroke();

        ctx.shadowBlur = 0;
      });

      // powerups
      powerUps.forEach(p=>{
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 18; ctx.shadowColor = '#ffd700';

        if (p.type === 'points'){
          // star polygon
          ctx.beginPath();
          for(let i=0;i<5;i++){
            const a = (i*2*Math.PI)/5 - Math.PI/2;
            const r = (i%2===0? p.size : p.size*0.45);
            const x = Math.cos(a)*r, y = Math.sin(a)*r;
            i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
          }
          ctx.closePath(); ctx.stroke();
        }else if (p.type === 'slow'){
          // clock
          ctx.beginPath(); ctx.arc(0,0,p.size,0,Math.PI*2); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-p.size*0.6);
          ctx.moveTo(0,0); ctx.lineTo(p.size*0.4,0); ctx.stroke();
        }else{
          // diamond shield
          ctx.beginPath();
          ctx.moveTo(0,-p.size); ctx.lineTo(p.size,0); ctx.lineTo(0,p.size); ctx.lineTo(-p.size,0); ctx.closePath(); ctx.stroke();
        }

        ctx.restore();
      });

      // particles
      particles.forEach(p=>{
        ctx.save();
        ctx.globalAlpha = Math.max(0, Math.min(1, p.life));
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x-2, p.y-2, 4, 4);
        ctx.restore();
      });

      // ship trail
      ship.trail.forEach((pt,i)=>{
        const alpha = (1 - i/ship.trail.length)*0.5;
        const size = ship.size*(1 - i/ship.trail.length);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = ship.color;
        ctx.beginPath();
        ctx.moveTo(pt.x, pt.y);
        ctx.lineTo(pt.x - size, pt.y - size/2);
        ctx.lineTo(pt.x - size, pt.y + size/2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      });

      // ship
      ctx.save();
      ctx.translate(ship.x, ship.y);
      ctx.shadowBlur = 24 + ship.glow*20;
      ctx.shadowColor = ship.color;

      // body
      ctx.fillStyle = ship.color;
      ctx.beginPath();
      ctx.moveTo(ship.size,0);
      ctx.lineTo(-ship.size, -ship.size);
      ctx.lineTo(-ship.size,  ship.size);
      ctx.closePath();
      ctx.fill();

      // cockpit
      ctx.fillStyle = 'rgba(255,255,255,.28)';
      ctx.beginPath();
      ctx.ellipse(0,0, ship.size*0.6, ship.size*0.4, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();

      // ghost aura
      if (ghostTimer>0){
        ctx.save();
        ctx.globalAlpha = 0.45 + 0.25*Math.sin(performance.now()*0.01);
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(ship.x, ship.y, ship.size*1.7, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      if (screenShake>0.1){ ctx.restore(); }
    }

    // ===== Loop =====
    function gameLoop(t = performance.now()){
      if (!gameRunning || paused) return;
      const dt = Math.min((t - lastTime)/1000, 0.033); // clamp big spikes
      lastTime = t;
      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }

    // ===== Initial draw so the menu has a nice bg =====
    draw();
  </script>
</body>
</html>
